"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeResolver = void 0;

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _NodeResolverBase() {
  const data = require("./NodeResolverBase");

  _NodeResolverBase = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class NodeResolver extends _NodeResolverBase().NodeResolverBase {
  async resolve(id, from) {
    if (id[0] === '.') {
      id = _path().default.resolve(from, id);
    }

    let res;

    if (_path().default.isAbsolute(id)) {
      res = await this.loadRelative(id);
    } else {
      res = await this.loadNodeModules(id, from);
    }

    if (!res) {
      let e = new Error(`Could not resolve module "${id}" from "${from}"`); // $FlowFixMe

      e.code = 'MODULE_NOT_FOUND';
      throw e;
    }

    if (_path().default.isAbsolute(res.resolved)) {
      res.resolved = await this.fs.realpath(res.resolved);
    }

    return res;
  }

  async loadRelative(id) {
    // Find a package.json file in the current package.
    let pkg = await this.findPackage(_path().default.dirname(id)); // First try as a file, then as a directory.

    return this.loadAsFile(id, pkg) || (await this.loadDirectory(id, pkg)) // eslint-disable-line no-return-await
    ;
  }

  findPackage(dir) {
    let pkgFile = this.fs.findAncestorFile(['package.json'], dir);

    if (pkgFile != null) {
      return this.readPackage(pkgFile);
    }

    return Promise.resolve(null);
  }

  async readPackage(file) {
    let cached = this.packageCache.get(file);

    if (cached) {
      return cached;
    }

    let json = await this.fs.readFile(file, 'utf8');
    let pkg = JSON.parse(json);
    this.packageCache.set(file, pkg);
    return pkg;
  }

  loadAsFile(file, pkg) {
    // Try all supported extensions
    let found = this.fs.findFirstFile(this.expandFile(file));

    if (found) {
      return {
        resolved: found,
        pkg
      };
    }

    return null;
  }

  async loadDirectory(dir, pkg = null) {
    try {
      pkg = await this.readPackage(dir + '/package.json'); // Get a list of possible package entry points.

      let entries = this.getPackageEntries(dir, pkg);

      for (let file of entries) {
        // First try loading package.main as a file, then try as a directory.
        const res = this.loadAsFile(file, pkg) || (await this.loadDirectory(file, pkg));

        if (res) {
          return res;
        }
      }
    } catch (err) {// ignore
    } // Fall back to an index file inside the directory.


    return this.loadAsFile(_path().default.join(dir, 'index'), pkg);
  }

  async loadNodeModules(id, from) {
    try {
      let module = this.findNodeModulePath(id, from);

      if (!module || module.resolved) {
        return module;
      } // If a module was specified as a module sub-path (e.g. some-module/some/path),
      // it is likely a file. Try loading it as a file first.


      if (module.subPath) {
        let pkg = await this.readPackage(module.moduleDir + '/package.json');
        let res = this.loadAsFile(module.filePath, pkg);

        if (res) {
          return res;
        }
      } // Otherwise, load as a directory.


      if (module.filePath) {
        return await this.loadDirectory(module.filePath);
      }
    } catch (e) {// ignore
    }
  }

}

exports.NodeResolver = NodeResolver;