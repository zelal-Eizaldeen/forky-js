"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeResolverBase = void 0;

function _module() {
  const data = _interopRequireDefault(require("module"));

  _module = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const builtins = {
  pnpapi: true
};

for (let builtin of _module().default.builtinModules) {
  builtins[builtin] = true;
}

class NodeResolverBase {
  constructor(fs, extensions) {
    _defineProperty(this, "fs", void 0);

    _defineProperty(this, "extensions", void 0);

    _defineProperty(this, "packageCache", void 0);

    this.fs = fs;
    this.extensions = extensions || Object.keys(_module().default._extensions);
    this.packageCache = new Map();
  }

  resolve(id, from) {
    throw new Error(`Could not resolve "${id}" from "${from}"`);
  }

  expandFile(file) {
    // Expand extensions and aliases
    let res = [];

    for (let ext of this.extensions) {
      res.push(file + ext);
    }

    if (_path().default.extname(file)) {
      res.unshift(file);
    } else {
      res.push(file);
    }

    return res;
  }

  getPackageEntries(dir, pkg) {
    let main = pkg.main;
    return [main].filter(entry => typeof entry === 'string').map(main => {
      // Default to index file if no main field find
      if (!main || main === '.' || main === './') {
        main = 'index';
      }

      (0, _assert().default)(typeof main === 'string');
      return _path().default.resolve(dir, main);
    });
  }

  getModuleParts(name) {
    let parts = _path().default.normalize(name).split(_path().default.sep);

    if (parts[0].charAt(0) === '@') {
      // Scoped module (e.g. @scope/module). Merge the first two parts back together.
      parts.splice(0, 2, `${parts[0]}/${parts[1]}`);
    }

    return parts;
  }

  isBuiltin(name) {
    return !!builtins[name];
  }

  findNodeModulePath(id, dir) {
    if (this.isBuiltin(id)) {
      return {
        resolved: id
      };
    }

    let [moduleName, ...parts] = this.getModuleParts(id);
    let moduleDir = this.fs.findNodeModule(moduleName, dir);

    if (!moduleDir && process.versions.pnp != null) {
      try {
        let pnp = _module().default.findPnpApi(dir + '/');

        moduleDir = pnp.resolveToUnqualified(moduleName + ( // retain slash in `require('assert/')` to force loading builtin from npm
        id[moduleName.length] === '/' ? '/' : ''), dir + '/');
      } catch (e) {
        if (e.code !== 'MODULE_NOT_FOUND') {
          throw e;
        }
      }
    }

    if (moduleDir) {
      return {
        moduleName,
        subPath: _path().default.join(...parts),
        moduleDir: moduleDir,
        filePath: parts.length > 0 ? _path().default.join(moduleDir, ...parts) : moduleDir
      };
    }

    return null;
  }

}

exports.NodeResolverBase = NodeResolverBase;